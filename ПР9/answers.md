# Ответы на вопросы для самоконтроля

## 1. В чем разница между временной сложностью O(n) и O(n²)?

**O(n)** - линейная сложность: время выполнения растет пропорционально размеру входных данных.
Пример: поиск максимума в массиве.

**O(n²)** - квадратичная сложность: время выполнения растет пропорционально квадрату размера входных данных.
Пример: пузырьковая сортировка.

## 2. Как работает алгоритм бинарного поиска и почему его сложность O(log n)?

Бинарный поиск работает только на отсортированных массивах. Алгоритм:
1. Находим средний элемент
2. Сравниваем с искомым значением
3. Если значение равно - возвращаем индекс
4. Если значение меньше - ищем в левой половине
5. Если значение больше - ищем в правой половине

Сложность O(log n) потому что на каждом шаге область поиска уменьшается вдвое.

## 3. Преимущества и недостатки пузырьковой сортировки

**Преимущества:**
- Простота реализации
- Стабильная сортировка
- In-place алгоритм (не требует дополнительной памяти)

**Недостатки:**
- Медленная для больших массивов (O(n²))
- На практике редко используется

## 4. Оптимизация функции проверки на простое число для больших чисел

В реализации используется оптимизация:
- Проверка делимости только до √n
- Исключение четных чисел после проверки 2
- Проверка делителей вида 6k ± 1

## 5. Разница между рекурсивной и итеративной реализацией Фибоначчи

**Рекурсивная:** 
- Более читаемая
- Экспоненциальная сложность O(2^n) без мемоизации
- Риск переполнения стека

**Итеративная:**
- Линейная сложность O(n)
- Эффективное использование памяти
- Предпочтительна для больших n

## 6. Методы отладки

- console.log() для трассировки значений
- Точки останова в DevTools
- Модульное тестирование
- Валидация edge cases

## 7. Алгоритм Евклида для НОД

Алгоритм основан на свойстве: 
НОД(a, b) = НОД(b, a mod b)

Эффективен потому что числа быстро уменьшаются на каждом шаге.

## 8. Edge cases для алгоритмов с массивами

- Пустой массив
- Массив с одним элементом
- Уже отсортированный массив
- Массив с одинаковыми элементами
- Очень большие массивы

## 9. Улучшение функции удаления дубликатов для больших массивов

- Использование Set (как в реализации)
- Сортировка + удаление соседних дубликатов (O(n log n))
- Хеш-таблицы для отслеживания уникальности

## 10. Принципы чистого кода

- Осмысленные имена переменных и функций
- Единая ответственность функций
- Комментарии для сложных алгоритмов
- Обработка edge cases
- Консистентное форматирование
- Отсутствие магических чисел