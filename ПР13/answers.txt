1.Promise.then().catch() vs async/await
Promise.then().catch() - функциональный стиль для цепочек. Async/await - императивный стиль, похожий на синхронный код. Используйте промисы для простых цепочек, async/await для сложной логики и лучшей читаемости.

2.Promise.all при ошибках
Promise.all ждет выполнения ВСЕХ промисов. Если ЛЮБОЙ промис отклоняется - весь Promise.all немедленно отклоняется с этой ошибкой. Остальные промисы продолжают выполняться, но их результаты игнорируются.

3.Promise.all vs race vs allSettled
Promise.all - все промисы должны выполниться. Promise.race - первый завершенный промис (успех или ошибка). Promise.allSettled - все промисы завершаются (любой результат). Примеры: all - параллельные API запросы, race - таймауты, allSettled - сбор статистики.

4.Повторные попытки с экспоненциальной задержкой

javascript
async function retry(operation, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      if (attempt === maxRetries) throw error;
      await new Promise(r => setTimeout(r, 100 * Math.pow(2, attempt)));
    }
  }
}

5.Состояние гонки и предотвращение
Состояние гонки - когда результат зависит от порядка выполнения асинхронных операций. Предотвращение: использовать async/await для последовательности, AbortController для отмены запросов, флаги для блокировки повторных вызовов.

6.Кэширование асинхронных запросов
Кэширование сохраняет результаты запросов для повторного использования. Стратегии: TTL (время жизни), LRU (вытеснение старых данных), инвалидация по событиям, in-memory кэш (Map/объекты).

7.Оптимизация производительности
Параллельное выполнение (Promise.all), кэширование, пагинация, ленивая загрузка, дебаунсинг/троттлинг, прерывание запросов (AbortController), пакетная обработка.

8.Обработка ошибок в промисах
Всегда добавлять .catch() в конец цепочек. Возвращать значения из .then(). Использовать async/await с try/catch. Пробрасывать ошибки с контекстом. Не игнорировать ошибки в then-блоках.

9.Преимущества async/await
Лучшая читаемость, полный стек вызовов при отладке, привычная обработка ошибок (try/catch), использование стандартных конструкций (if/for), простой поток управления, легкая комбинация с другими конструкциями.

10.Отладка асинхронного кода
Инструменты: Async Stack Traces в DevTools, console.trace(), брейкпоинты в асинхронных функциях, Performance tab для анализа времени, Network tab для мониторинга запросов. Лучшие практики: логирование этапов, использование Promise.allSettled для диагностики.