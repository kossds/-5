1. Какие методы HTTP используются для CRUD операций и в каких случаях?

POST (Create): Используется для создания новых ресурсов на сервере. Например, создание нового пользователя или статьи.

GET (Read): Используется для получения (чтения) информации о ресурсе или списка ресурсов. Не должен изменять данные на сервере.

PUT (Update): Используется для полного обновления существующего ресурса. Клиент отправляет обновленное представление всего ресурса.

PATCH (Update): Используется для частичного обновления ресурса. Клиент отправляет только те поля, которые необходимо изменить.

DELETE (Delete): Используется для удаления указанного ресурса с сервера.

2. Как организовать обработку ошибок на фронтенде при работе с API?

Обработка ошибок организуется через анализ HTTP-статусов и тела ответа от сервера. Основные подходы включают перехват всех исходящих запросов и входящих ответов с помощью интерсепторов, классификацию ошибок по типам (например, клиентские 4xx, серверные 5xx, сетевые сбои) и создание централизованного механизма для уведомления пользователя. Пользователю показываются понятные сообщения, соответствующие типу ошибки, в то время как технические детали могут логироваться для разработчика.

3. Что такое CORS и как его настроить для разработки?

CORS (Cross-Origin Resource Sharing) — это механизм безопасности браузера, который разрешает или запрещает запросы к ресурсам на другом домене (origin), отличном от того, с которого был загружен фронтенд. Для настройки в разработке обычно используется прокси-сервер, который перенаправляет запросы с фронтенда на бэкенд, чтобы они были с одного домена, либо на бэкенде настраиваются специальные CORS-заголовки (например, Access-Control-Allow-Origin), которые разрешают запросы с адреса, на котором работает приложение для разработки.

4. Какие подходы к управлению состоянием при интеграции с API вы знаете?

Основные подходы включают использование серверного состояния, клиентского состояния и их комбинации. Популярные решения — это специализированные библиотеки для управления серверным состоянием (такие как React Query, SWR, Apollo Client), которые занимаются кэшированием, синхронизацией и обновлением данных. Также используются общие менеджеры состояния (как Redux, Zustand) для хранения как клиентских данных, так и данных с сервера, хотя в этом случае всю логику обновления (запросы, инвалидация) часто приходится писать вручную.

5. Как реализовать индикацию загрузки без ухудшения UX?

Для этого используются скелетоны (заглушки контента) вместо спиннеров, так как они готовят пользователя к структуре контента. Локальные индикаторы загрузки (например, только для кнопки, которая была нажата) предпочтительнее глобальных, которые блокируют весь интерфейс. Также применяется стратегия отложенной загрузки, когда сначала отображаются части интерфейса, не требующие ожидания, а индикатор показывается только для контента, который еще загружается.

6. В чем преимущества и недостатки оптимистичных обновлений?

Преимущества: Мгновенный отклик интерфейса и улучшенное воспринимаемое производительность, что приводит к лучшему пользовательскому опыту.

Недостатки: Риск рассогласования состояния между клиентом и сервером, если запрос завершится ошибкой. Это требует реализации сложной логики отката изменений и уведомления пользователя об ошибке уже после того, как действие было "успешно" выполнено в интерфейсе.

7. Как организовать валидацию данных на клиенте и сервере?

Валидация должна быть двухуровневой. На клиенте она используется для быстрой обратной связи пользователю, проверяет базовую корректность (обязательные поля, формат email) и предотвращает лишние запросы. На сервере валидация является обязательной и критически важной для безопасности, она проверяет данные на корректность, полноту и соответствие бизнес-логике, защищая приложение от злонамеренных или некорректных запросов.

8. Какие методы кэширования данных с сервера можно использовать?

Основные методы включают HTTP-кэширование через заголовки (например, Cache-Control, ETag), которое управляется браузером. Кэширование в памяти фронтенд-приложения с использованием state-менеджеров или специализированных библиотек. А также кэширование в постоянном хранилище браузера (например, localStorage или IndexedDB) для работы в офлайн-режиме или для данных, которые редко меняются.