1. Разница между Fetch API и XMLHttpRequest
Fetch API — современный стандарт на Промисах, с более чистым синтаксисом. XMLHttpRequest — устаревший событийный API. Fetch предоставляет лучшую обработку заголовков и логичную структуру ответов.

2. Обработка ошибок в Fetch API
Fetch не считает HTTP-ошибки (404, 500) провалом промиса — только сетевые сбои. Ошибки статусов нужно обрабатывать вручную проверкой response.ok или response.status.

3. HTTP-методы в Fetch API
Поддерживает GET (получение), POST (создание), PUT (полное обновление), PATCH (частичное обновление), DELETE (удаление). Метод указывается в настройках запроса.

4. Работа с заголовками
Заголовки запроса задаются через объект headers. Заголовки ответа доступны через response.headers. Важные заголовки: Content-Type, Authorization, Cache-Control.

5. PUT vs PATCH
PUT полностью заменяет ресурс, PATCH вносит частичные изменения. PUT используем когда нужно обновить весь ресурс, PATCH — когда только отдельные поля.

6. Авторизация в Fetch API
Реализуется через заголовок Authorization: Basic Auth (логин/пароль в base64), Bearer Token (JWT), OAuth2 (токен доступа как Bearer Token).

7. Отмена запросов
Через AbortController. Создается контроллер, его signal передается в fetch, вызов controller.abort() отменяет запрос. Используется при уходе со страницы или повторном запросе.

8. Форматы данных
JSON: самый частый вариант. FormData: для файлов и форм. Blob/ArrayBuffer: для бинарных данных. Для обработки используются методы response.json(), .blob() и другие.

9. Оптимизация множественных запросов
Параллельное выполнение через Promise.all(). Кэширование: HTTP-кеш браузера и собственный in-memory кеш для повторяющихся данных.

10. Лучшие практики
Всегда проверять HTTP-статусы, создавать обертку для запросов, использовать async/await, отменять неактуальные запросы, настраивать таймауты, правильно обрабатывать безопасность.