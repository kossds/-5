Часть 7: Вопросы для самоконтроля
1.В чем разница между селектором по классу и по ID с точки зрения специфичности и возможности повторного использования?

Специфичность: Селектор по ID имеет очень высокую специфичность: 1,0,0,0. Селектор по классу имеет более низкую специфичность: 0,1,0,0. Правило с ID почти всегда переопределит правило с классом.
Повторное использование:
Класс (.my-class): Предназначен для многократного использования. Его можно применить к любому количеству элементов на странице. Это основной инструмент для модульного и гибкого CSS.
ID (#my-id): Предназначен для уникального элемента на странице. Согласно стандартам HTML, ID должен быть использован только один раз в документе. Из-за высокой специфичности и ограниченности в повторном использовании ID редко используются для стилизации, но могут использоваться для структурных элементов или якорей.

2.Как работает каскад в CSS и в каком порядке применяются стили при конфликте правил?

Каскад (от англ. cascade) — это алгоритм, который CSS использует для разрешения конфликтов, когда несколько правил пытаются применить стили к одному и тому же элементу.
Порядок применения стилей (при одинаковой важности и специфичности, от низшего к высшему):
Порядок источника (Origin): Стили браузера по умолчанию (User Agent Styles).
Порядок источника (Origin): Стили пользователя (User Styles, например, в настройках доступности).
Порядок источника (Origin): Стили автора (Author Styles), т.е. ваши стили (styles.css).
Важность (!important): Стили, помеченные как !important, перебивают все остальные, но их использование не рекомендуется.

3.Рассчитайте специфичность для селекторов:
Специфичность рассчитывается по формуле (ID, Классы/Атрибуты/Псевдоклассы, Элементы/Псевдоэлементы):
ul li.important → (0, 1, 2): 0 ID, 1 класс (.important), 2 тега (ul, li).
#site-title → (1, 0, 0): 1 ID (#site-title), 0 классов, 0 тегов.
.content > .featured-post → (0, 2, 0): 0 ID, 2 класса (.content, .featured-post), 0 тегов.

4.Какие свойства в CSS наследуются по умолчанию, а какие нет? Приведите по 3 примера каждого типа.

Наследуемые свойства (применяются к дочерним элементам, если не переопределены):
color (цвет текста)
fоnt-family, font-size, font-weight (свойства шрифта)
line-height (высота строки)
Ненаследуемые свойства (должны быть явно применены к дочерним элементам):
border (границы)
margin, padding (внешние и внутренние отступы)
background-color, background-image (фон)

5.Как работает селектор > (дочерний селектор) и чем он отличается от селектора потомков (через пробел)?

Дочерний селектор (>): Выбирает только непосредственных потомков элемента.
Пример: ul > li выберет только те <li>, которые являются прямыми детьми <ul>. Он проигнорирует <li> внутри вложенных списков.
Селектор потомков (через пробел): Выбирает всех потомков элемента, независимо от уровня вложенности.
Пример: ul li выберет все <li>, которые находятся внутри <ul>, даже если они вложены через несколько уровней.

6.Для чего используются псевдоклассы :hover и :nth-child()? В каких практических задачах они могут пригодиться?

:hover (состояние): Применяет стили, когда пользователь наводит курсор мыши на элемент.
Практическая задача: Изменение цвета кнопки или ссылки, увеличение карточки товара для визуального отклика пользователя.
:nth-child(n) (структура): Выбирает элемент, который является n-ым ребенком своего родителя.
Практическая задача: Создание "зебры" в таблицах (:nth-child(odd) или :nth-child(2n)) для лучшей читаемости; выделение первого или последнего элемента списка.

7.Что делает правило !important и почему его следует использовать с осторожностью?

Правило !important, добавленное к значению свойства (color: red !important;), предоставляет этому правилу наивысший приоритет, переопределяя все остальные стили, включая стили с более высокой специфичностью, а также стили из внешних таблиц.
Почему использовать с осторожностью:
Нарушает Каскад: Делает отладку и понимание кода крайне сложными, так как нарушает предсказуемый механизм каскада и специфичности.
Сложность переопределения: Чтобы переопределить правило с !important, вам придется использовать другое !important (или инлайн-стиль), что ведет к "войне приоритетов".

8.Как псевдоэлементы ::before и ::after расширяют возможности CSS и какой контент они могут содержать?

Псевдоэлементы ::before и ::after позволяют вставлять генерируемый контент в документ до (::before) или после (::after) содержимого выбранного элемента, не добавляя при этом дополнительных HTML-тегов.
Расширение возможностей: Они используются для декоративных целей, таких как:
Добавление иконок (как в моем примере со ⭐).
Очистка плавающих элементов (свойство clearfix).
Создание геометрических фигур (например, стрелок, треугольников) или декоративных линий.
Содержимый контент: Они могут содержать текст или специальные символы, заданные с помощью свойства content: "текст" или content: url(...).

9.В каком порядке браузер применяет CSS-правила при одинаковой специфичности селекторов?
При абсолютно одинаковой специфичности селекторов и одинаковом источнике (например, оба правила в styles.css), применяется правило, которое находится ниже (позже) в таблице стилей. Это называется правилом порядка источника.

10.Как инструменты разработчика в браузере помогают анализировать и отлаживать CSS-код?
Инструменты разработчика (DevTools, обычно вызываются клавишей F12) являются критически важными для работы с CSS:
Просмотр примененных стилей: Показывают все стили, примененные к выбранному элементу.
Анализ специфичности и каскада: Четко показывают, какие правила были применены, какие были перечеркнуты (переопределены), и откуда они пришли (файл и строка), помогая понять, почему конкретный стиль не сработал.
Живая отладка: Позволяют изменять значения свойств, добавлять или удалять селекторы и правила прямо в браузере (без изменения исходного файла) для мгновенного тестирования эффекта.
Моделирование псевдоклассов: Позволяют принудительно активировать состояния вроде :hover, :active и :focus для отладки их стилей.
